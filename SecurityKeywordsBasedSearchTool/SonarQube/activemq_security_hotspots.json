[
    {
        "projectName": "activemq",
        "fileName": "simple-auth-amqp-broker.xml",
        "filePath": "activemq-amqp/src/test/resources/org/apache/activemq/transport/amqp/simple-auth-amqp-broker.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "42 - 42",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "simple-auth-amqp-broker.xml",
        "filePath": "activemq-amqp/src/test/resources/org/apache/activemq/transport/amqp/simple-auth-amqp-broker.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "43 - 43",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "simple-auth-amqp-broker.xml",
        "filePath": "activemq-amqp/src/test/resources/org/apache/activemq/transport/amqp/simple-auth-amqp-broker.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "44 - 44",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "authenticationTest-two-users.xml",
        "filePath": "activemq-runtime-config/src/test/resources/org/apache/activemq/authenticationTest-two-users.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "30 - 30",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "authenticationTest-two-users.xml",
        "filePath": "activemq-runtime-config/src/test/resources/org/apache/activemq/authenticationTest-two-users.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "31 - 31",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "authenticationTest-users.xml",
        "filePath": "activemq-runtime-config/src/test/resources/org/apache/activemq/authenticationTest-users.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "28 - 28",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "localBroker-authn.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/network/localBroker-authn.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "34 - 34",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "localBroker-authn.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/network/localBroker-authn.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "48 - 48",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "localBroker-authn.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/network/localBroker-authn.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "49 - 49",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "localBroker-remote-userName.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/network/localBroker-remote-userName.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "34 - 34",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "localBroker-remote-userName.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/network/localBroker-remote-userName.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "50 - 50",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "localBroker-remote-userName.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/network/localBroker-remote-userName.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "51 - 51",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "remoteBroker-authn.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/network/remoteBroker-authn.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "29 - 29",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "remoteBroker-authn.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/network/remoteBroker-authn.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "34 - 34",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "remoteBroker-authn.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/network/remoteBroker-authn.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "35 - 35",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "activemq-apacheds-legacy.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/security/activemq-apacheds-legacy.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "33 - 33",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "activemq-apacheds-legacy.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/security/activemq-apacheds-legacy.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "35 - 35",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "activemq-apacheds.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/security/activemq-apacheds.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "33 - 33",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "activemq-apacheds.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/security/activemq-apacheds.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "35 - 35",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "activemq-ldap.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/security/activemq-ldap.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "37 - 37",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "activemq-ldap.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/security/activemq-ldap.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "39 - 39",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "activemq-openldap.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/security/activemq-openldap.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "33 - 33",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "activemq-openldap.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/security/activemq-openldap.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "35 - 35",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "simple-anonymous-broker.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/security/simple-anonymous-broker.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "56 - 56",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "simple-anonymous-broker.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/security/simple-anonymous-broker.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "58 - 58",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "simple-anonymous-broker.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/security/simple-anonymous-broker.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "60 - 60",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "receiver-secured.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/usecases/receiver-secured.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "28 - 28",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "receiver-secured.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/usecases/receiver-secured.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "38 - 38",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "receiver-secured.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/usecases/receiver-secured.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "40 - 40",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "receiver-secured.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/usecases/receiver-secured.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "42 - 42",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "sender-secured.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/usecases/sender-secured.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "28 - 28",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "sender-secured.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/usecases/sender-secured.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "42 - 42",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "sender-secured.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/usecases/sender-secured.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "44 - 44",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "sender-secured.xml",
        "filePath": "activemq-unit-tests/src/test/resources/org/apache/activemq/usecases/sender-secured.xml",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "46 - 46",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nIn\nspring social twitter\n, retrieve secrets from\nenvironment variables:\n@Configuration\npublic class SocialConfig implements SocialConfigurer {\n@Override\npublic void addConnectionFactories(ConnectionFactoryConfigurer cfConfig, Environment env) {\ncfConfig.addConnectionFactory(new TwitterConnectionFactory(\nenv.getProperty(\"twitter.consumerKey\"),\nenv.getProperty(\"twitter.consumerSecret\")));  <!-- Compliant -->\n}\n}\nSee\nOWASP Top 10 2021 Category A7\n- Identification and\nAuthentication Failures\nOWASP Top 10 2017 Category A2\n- Broken Authentication\nMITRE, CWE-798\n- Use of Hard-coded Credentials\nMITRE, CWE-259\n- Use of Hard-coded Password\nSANS Top 25\n- Porous Defenses\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "mqttws31.js",
        "filePath": "activemq-web-demo/src/main/webapp/mqtt/mqttws31.js",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "1533 - 1533",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nvar mysql = require('mysql');\nvar connection = mysql.createConnection({\nhost: process.env.MYSQL_URL,\nuser: process.env.MYSQL_USERNAME,\npassword: process.env.MYSQL_PASSWORD,\ndatabase: process.env.MYSQL_DATABASE\n});\nconnection.connect();\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "mqttws31.js",
        "filePath": "assembly/src/release/examples/mqtt/websocket/js/mqttws31.js",
        "Security Category": "auth",
        "Description": "Hard-coded credentials are security-sensitive",
        "Location": "1533 - 1533",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nvar mysql = require('mysql');\nvar connection = mysql.createConnection({\nhost: process.env.MYSQL_URL,\nuser: process.env.MYSQL_USERNAME,\npassword: process.env.MYSQL_PASSWORD,\ndatabase: process.env.MYSQL_DATABASE\n});\nconnection.connect();\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "NetworkConnectorView.java",
        "filePath": "activemq-broker/src/main/java/org/apache/activemq/broker/jmx/NetworkConnectorView.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "23 - 23",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "ShellCommand.java",
        "filePath": "activemq-console/src/main/java/org/apache/activemq/console/command/ShellCommand.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "68 - 68",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "EncryptableLDAPLoginModule.java",
        "filePath": "activemq-jaas/src/main/java/org/apache/activemq/jaas/EncryptableLDAPLoginModule.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "36 - 36",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "EncryptableLDAPLoginModule.java",
        "filePath": "activemq-jaas/src/main/java/org/apache/activemq/jaas/EncryptableLDAPLoginModule.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "38 - 38",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "LDAPLoginModuleTest.java",
        "filePath": "activemq-jaas/src/test/java/org/apache/activemq/jaas/LDAPLoginModuleTest.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "87 - 87",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "LDAPModuleRoleExpansionTest.java",
        "filePath": "activemq-jaas/src/test/java/org/apache/activemq/jaas/LDAPModuleRoleExpansionTest.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "82 - 82",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "PropertiesLoginModuleRaceConditionTest.java",
        "filePath": "activemq-jaas/src/test/java/org/apache/activemq/jaas/PropertiesLoginModuleRaceConditionTest.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "51 - 51",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "KarafShellHelper.java",
        "filePath": "activemq-karaf-itest/src/test/java/org/apache/activemq/karaf/itest/KarafShellHelper.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "40 - 40",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "PahoVirtualTopicMQTTTest.java",
        "filePath": "activemq-mqtt/src/test/java/org/apache/activemq/transport/mqtt/PahoVirtualTopicMQTTTest.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "48 - 48",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "PahoVirtualTopicMQTTTest.java",
        "filePath": "activemq-mqtt/src/test/java/org/apache/activemq/transport/mqtt/PahoVirtualTopicMQTTTest.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "60 - 60",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "PooledConsumerTest.java",
        "filePath": "activemq-pool/src/test/java/org/apache/activemq/pool/PooledConsumerTest.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "57 - 57",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "AbstractRuntimeConfigurationBroker.java",
        "filePath": "activemq-runtime-config/src/main/java/org/apache/activemq/plugin/AbstractRuntimeConfigurationBroker.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "167 - 167",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "DefaultConfigurationProcessor.java",
        "filePath": "activemq-runtime-config/src/main/java/org/apache/activemq/plugin/DefaultConfigurationProcessor.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "39 - 39",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "AMQ3411Test.java",
        "filePath": "activemq-unit-tests/src/test/java/org/apache/activemq/console/command/AMQ3411Test.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "44 - 44",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "SslTransportTest.java",
        "filePath": "activemq-unit-tests/src/test/java/org/apache/activemq/transport/tcp/SslTransportTest.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "46 - 46",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "activemq",
        "fileName": "JDBCMessagePriorityTest.java",
        "filePath": "activemq-unit-tests/src/test/java/org/apache/activemq/store/jdbc/JDBCMessagePriorityTest.java",
        "Security Category": "sql-injection",
        "Description": "Formatting SQL queries is security-sensitive",
        "Location": "396 - 396",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nUse\nparameterized queries, prepared\nstatements, or stored procedures\nand bind variables to SQL query parameters.\nConsider using ORM frameworks if there is a need to have an abstract layer to access data.\nCompliant Solution\npublic User getUser(Connection con, String user) throws SQLException {\nStatement stmt1 = null;\nPreparedStatement pstmt = null;\nString query = \"select FNAME, LNAME, SSN \" +\n\"from USERS where UNAME=?\"\ntry {\nstmt1 = con.createStatement();\nResultSet rs1 = stmt1.executeQuery(\"GETDATE()\");\npstmt = con.prepareStatement(query);\npstmt.setString(1, user);  // Good; PreparedStatements escape their inputs.\nResultSet rs2 = pstmt.executeQuery();\n//...\n}\n}\npublic User getUserHibernate(org.hibernate.Session session, String data) {\norg.hibernate.Query query =  session.createQuery(\"FROM students where fname = ?\");\nquery = query.setParameter(0,data);  // Good; Parameter binding escapes all input\norg.hibernate.Query query2 =  session.createQuery(\"FROM students where fname = \" + data); // Sensitive\n// ...\nSee\nOWASP -\nTop 10 2021 Category A3 - Injection\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-89 - Improper Neutralization of Special Elements used in an SQL Command\nCWE -\nCWE-564 - SQL Injection: Hibernate\nCWE -\nCWE-20 - Improper Input Validation\nCWE -\nCWE-943 - Improper Neutralization of Special Elements in Data Query Logic\nCERT, IDS00-J.\n- Prevent SQL injection\nDerived from FindSecBugs rules\nPotential SQL/JPQL Injection\n(JPA)\n,\nPotential SQL/JDOQL Injection (JDO)\n,\nPotential SQL/HQL Injection (Hibernate)"
    },
    {
        "projectName": "activemq",
        "fileName": "stomp.js",
        "filePath": "activemq-http/src/test/webapp/stomp.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "58 - 58",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "MochiKit.js",
        "filePath": "activemq-web-console/src/main/webapp/js/mochi/MochiKit.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "1874 - 1874",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "MochiKit.js",
        "filePath": "activemq-web-console/src/main/webapp/js/mochi/MochiKit.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "1975 - 1975",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "MochiKit.js",
        "filePath": "activemq-web-console/src/main/webapp/js/mochi/MochiKit.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "3734 - 3734",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "SVG.js",
        "filePath": "activemq-web-console/src/main/webapp/js/plotkit/SVG.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "650 - 650",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prettify.js",
        "filePath": "activemq-web-console/src/main/webapp/js/prettify.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "438 - 447",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prettify.js",
        "filePath": "activemq-web-console/src/main/webapp/js/prettify.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "956 - 956",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "standardista-table-sorting.js",
        "filePath": "activemq-web-console/src/main/webapp/js/standardista-table-sorting.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "281 - 281",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "385 - 385",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "620 - 620",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "624 - 624",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "653 - 653",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "701 - 701",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "1820 - 1820",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "4614 - 4614",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "4619 - 4619",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "4630 - 4632",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "4634 - 4635",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "jsunittest.js",
        "filePath": "activemq-web-demo/src/main/webapp/test/assets/jsunittest.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "109 - 109",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "jsunittest.js",
        "filePath": "activemq-web-demo/src/main/webapp/test/assets/jsunittest.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "164 - 164",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "jsunittest.js",
        "filePath": "activemq-web-demo/src/main/webapp/test/assets/jsunittest.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "164 - 164",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "stomp.js",
        "filePath": "activemq-web-demo/src/main/webapp/websocket/stomp.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "58 - 58",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "behaviour.js",
        "filePath": "activemq-web/src/main/resources/org/apache/activemq/web/behaviour.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "122 - 122",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "behaviour.js",
        "filePath": "activemq-web/src/main/resources/org/apache/activemq/web/behaviour.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "169 - 169",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web/src/main/resources/org/apache/activemq/web/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "385 - 385",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web/src/main/resources/org/apache/activemq/web/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "620 - 620",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web/src/main/resources/org/apache/activemq/web/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "624 - 624",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web/src/main/resources/org/apache/activemq/web/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "653 - 653",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web/src/main/resources/org/apache/activemq/web/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "701 - 701",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web/src/main/resources/org/apache/activemq/web/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "1820 - 1820",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web/src/main/resources/org/apache/activemq/web/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "4614 - 4614",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web/src/main/resources/org/apache/activemq/web/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "4619 - 4619",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web/src/main/resources/org/apache/activemq/web/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "4630 - 4632",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web/src/main/resources/org/apache/activemq/web/prototype.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "4634 - 4635",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "stomp.js",
        "filePath": "assembly/src/release/examples/stomp/websocket/js/stomp.js",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "44 - 44",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid catastrophic backtracking situations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen.\nIf you have a repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different possible matches (of\npossibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains\noptional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only one way to match it).\nIf you have multiple repetitions that can match the same contents and are consecutive or are only separated by an optional separator or a\nseparator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the number of\nproblematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different things and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n. However,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails, the\nregex engine will try again starting at the next index. This means that any unbounded repetition, if it\u2019s followed by a pattern that can fail, can\ncause quadratic runtime on some inputs. For example\nstr.split(/\\s*,/)\nwill run in quadratic time on strings that consist entirely of\nspaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor nested quantifiers to limit the number of way the inner group can be matched by the outer quantifier, for instance this nested\nquantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists exactly one\nb\nchar per repetition of the group.\nOptimize regular expressions by emulating\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when the regex is not\nanchored to the beginning of the string, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nnode-re2\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(/\\s*,\\s*/)\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nIt is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course\nthis means that you\u2019ll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were\nmatched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand\nthen the call to\nstr.match(regex)\ncould be replaced with\nmatched = str.match(regex)\nand\nmatched[1] !==\nundefined\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues. Unfortunately, they are not\nsupported in JavaScript, but one can still mimick them using lookahead assertions and backreferences:\n/((?=(a+))\\2)+$/.test(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\"\n); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "ManagementContext.java",
        "filePath": "activemq-broker/src/main/java/org/apache/activemq/broker/jmx/ManagementContext.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "589 - 589",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "XBeanByteConverterUtil.java",
        "filePath": "activemq-broker/src/main/java/org/apache/activemq/util/XBeanByteConverterUtil.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "29 - 29",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "ActiveMQConnectionMetaData.java",
        "filePath": "activemq-client/src/main/java/org/apache/activemq/ActiveMQConnectionMetaData.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "50 - 50",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "PurgeCommand.java",
        "filePath": "activemq-console/src/main/java/org/apache/activemq/console/command/PurgeCommand.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "210 - 210",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "activemq",
        "fileName": "Dockerfile",
        "filePath": "assembly/src/docker/Dockerfile",
        "Security Category": "permission",
        "Description": "Running containers as a privileged user is security-sensitive",
        "Location": "19 - 19",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nIn the Dockerfile:\nCreate a new default user and use it with the\nUSER\nstatement.\nSome container maintainers create a specific user to be used without explicitly setting it as default, such as\npostgresql\nor\nzookeeper\n. It is recommended to use these users instead of root.\nOn Windows containers, the\nContainerUser\nis available for this purpose.\nOr, at launch time:\nUse the\nuser\nargument when calling Docker or in the docker-compose file.\nAdd fine-grained Linux capabilities to perform specific actions that require root privileges.\nIf this image is already explicitly set to launch with a non-privileged user, you can add it to the safe images list rule property of your\nSonarQube instance, without the tag.\nCompliant Solution\nFor Linux-based images and scratch-based images that untar a Linux distribution:\nFROM alpine\nRUN addgroup -S nonroot \\\n&& adduser -S nonroot -G nonroot\nUSER nonroot\nENTRYPOINT [\"id\"]\nFor Windows-based images, you can use\nContainerUser\nor create a new user:\nFROM mcr.microsoft.com/windows/servercore:ltsc2019\nRUN net user /add nonroot\nUSER nonroot\nFor multi-stage builds, the non-root user should be on the last stage:\nFROM alpine as builder\nCOPY Makefile ./src /\nRUN make build\nFROM alpine as runtime\nRUN addgroup -S nonroot \\\n&& adduser -S nonroot -G nonroot\nCOPY --from=builder bin/production /app\nUSER nonroot\nENTRYPOINT [\"/app/production\"]\nFor images that use\nscratch\nas their base, it is not possible to add non-privileged users by default. To do this, add an additional\nbuild stage to add the group and user, and later copy\n/etc/passwd\n.\nHere is an example that uses\nadduser\nin the first stage to generate a user and add it to the\n/etc/passwd\nfile. In the\nnext stage, this user is added by copying that file over from the previous stage:\nFROM alpine:latest as security_provider\nRUN addgroup -S nonroot \\\n&& adduser -S nonroot -G nonroot\nFROM scratch as production\nCOPY --from=security_provider /etc/passwd /etc/passwd\nUSER nonroot\nCOPY production_binary /app\nENTRYPOINT [\"/app/production_binary\"]\nSee\nCWE -\nCWE-284 - Improper Access Control\nnginxinc/nginx-unprivileged: Example of a non-root container by default\nMicrosoft docs, When to use ContainerAdmin and ContainerUser user accounts"
    },
    {
        "projectName": "activemq",
        "fileName": "MochiKit.js",
        "filePath": "activemq-web-console/src/main/webapp/js/mochi/MochiKit.js",
        "Security Category": "rce",
        "Description": "Dynamically executing code is security-sensitive",
        "Location": "394 - 394",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nRegarding the execution of unknown code, the best solution is to not run code provided by an untrusted source. If you really need to do it, run the\ncode in a\nsandboxed\nenvironment. Use jails, firewalls and whatever means your\noperating system and programming language provide (example:\nSecurity Managers\nin java,\niframes\nand\nsame-origin\npolicy\nfor javascript in a web browser).\nDo not try to create a blacklist of dangerous code. It is impossible to cover all attacks that way.\nAvoid using dynamic code APIs whenever possible. Hard-coded code is always safer.\nSee\nOWASP -\nTop 10 2021 Category A3 - Injection\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-95 - Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval\nInjection')"
    },
    {
        "projectName": "activemq",
        "fileName": "MochiKit.js",
        "filePath": "activemq-web-console/src/main/webapp/js/mochi/MochiKit.js",
        "Security Category": "rce",
        "Description": "Dynamically executing code is security-sensitive",
        "Location": "556 - 556",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nRegarding the execution of unknown code, the best solution is to not run code provided by an untrusted source. If you really need to do it, run the\ncode in a\nsandboxed\nenvironment. Use jails, firewalls and whatever means your\noperating system and programming language provide (example:\nSecurity Managers\nin java,\niframes\nand\nsame-origin\npolicy\nfor javascript in a web browser).\nDo not try to create a blacklist of dangerous code. It is impossible to cover all attacks that way.\nAvoid using dynamic code APIs whenever possible. Hard-coded code is always safer.\nSee\nOWASP -\nTop 10 2021 Category A3 - Injection\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-95 - Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval\nInjection')"
    },
    {
        "projectName": "activemq",
        "fileName": "MochiKit.js",
        "filePath": "activemq-web-console/src/main/webapp/js/mochi/MochiKit.js",
        "Security Category": "rce",
        "Description": "Dynamically executing code is security-sensitive",
        "Location": "2202 - 2202",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nRegarding the execution of unknown code, the best solution is to not run code provided by an untrusted source. If you really need to do it, run the\ncode in a\nsandboxed\nenvironment. Use jails, firewalls and whatever means your\noperating system and programming language provide (example:\nSecurity Managers\nin java,\niframes\nand\nsame-origin\npolicy\nfor javascript in a web browser).\nDo not try to create a blacklist of dangerous code. It is impossible to cover all attacks that way.\nAvoid using dynamic code APIs whenever possible. Hard-coded code is always safer.\nSee\nOWASP -\nTop 10 2021 Category A3 - Injection\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-95 - Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval\nInjection')"
    },
    {
        "projectName": "activemq",
        "fileName": "MochiKit.js",
        "filePath": "activemq-web-console/src/main/webapp/js/mochi/MochiKit.js",
        "Security Category": "rce",
        "Description": "Dynamically executing code is security-sensitive",
        "Location": "2826 - 2826",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nRegarding the execution of unknown code, the best solution is to not run code provided by an untrusted source. If you really need to do it, run the\ncode in a\nsandboxed\nenvironment. Use jails, firewalls and whatever means your\noperating system and programming language provide (example:\nSecurity Managers\nin java,\niframes\nand\nsame-origin\npolicy\nfor javascript in a web browser).\nDo not try to create a blacklist of dangerous code. It is impossible to cover all attacks that way.\nAvoid using dynamic code APIs whenever possible. Hard-coded code is always safer.\nSee\nOWASP -\nTop 10 2021 Category A3 - Injection\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-95 - Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval\nInjection')"
    },
    {
        "projectName": "activemq",
        "fileName": "MochiKit.js",
        "filePath": "activemq-web-console/src/main/webapp/js/mochi/MochiKit.js",
        "Security Category": "rce",
        "Description": "Dynamically executing code is security-sensitive",
        "Location": "2850 - 2850",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nRegarding the execution of unknown code, the best solution is to not run code provided by an untrusted source. If you really need to do it, run the\ncode in a\nsandboxed\nenvironment. Use jails, firewalls and whatever means your\noperating system and programming language provide (example:\nSecurity Managers\nin java,\niframes\nand\nsame-origin\npolicy\nfor javascript in a web browser).\nDo not try to create a blacklist of dangerous code. It is impossible to cover all attacks that way.\nAvoid using dynamic code APIs whenever possible. Hard-coded code is always safer.\nSee\nOWASP -\nTop 10 2021 Category A3 - Injection\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-95 - Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval\nInjection')"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "rce",
        "Description": "Dynamically executing code is security-sensitive",
        "Location": "640 - 640",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nRegarding the execution of unknown code, the best solution is to not run code provided by an untrusted source. If you really need to do it, run the\ncode in a\nsandboxed\nenvironment. Use jails, firewalls and whatever means your\noperating system and programming language provide (example:\nSecurity Managers\nin java,\niframes\nand\nsame-origin\npolicy\nfor javascript in a web browser).\nDo not try to create a blacklist of dangerous code. It is impossible to cover all attacks that way.\nAvoid using dynamic code APIs whenever possible. Hard-coded code is always safer.\nSee\nOWASP -\nTop 10 2021 Category A3 - Injection\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-95 - Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval\nInjection')"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "rce",
        "Description": "Dynamically executing code is security-sensitive",
        "Location": "744 - 744",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nRegarding the execution of unknown code, the best solution is to not run code provided by an untrusted source. If you really need to do it, run the\ncode in a\nsandboxed\nenvironment. Use jails, firewalls and whatever means your\noperating system and programming language provide (example:\nSecurity Managers\nin java,\niframes\nand\nsame-origin\npolicy\nfor javascript in a web browser).\nDo not try to create a blacklist of dangerous code. It is impossible to cover all attacks that way.\nAvoid using dynamic code APIs whenever possible. Hard-coded code is always safer.\nSee\nOWASP -\nTop 10 2021 Category A3 - Injection\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-95 - Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval\nInjection')"
    },
    {
        "projectName": "activemq",
        "fileName": "prototype.js",
        "filePath": "activemq-web-demo/src/main/webapp/js/prototype.js",
        "Security Category": "rce",
        "Description": "Dynamically executing code is security-sensitive",
        "Location": "1853 - 1853",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nRegarding the execution of unknown code, the best solution is to not run code provided by an untrusted source. If you really need to do it, run the\ncode in a\nsandboxed\nenvironment. Use jails, firewalls and whatever means your\noperating system and programming language provide (example:\nSecurity Managers\nin java,\niframes\nand\nsame-origin\npolicy\nfor javascript in a web browser).\nDo not try to create a blacklist of dangerous code. It is impossible to cover all attacks that way.\nAvoid using dynamic code APIs whenever possible. Hard-coded code is always safer.\nSee\nOWASP -\nTop 10 2021 Category A3 - Injection\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-95 - Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval\nInjection')"
    }
]