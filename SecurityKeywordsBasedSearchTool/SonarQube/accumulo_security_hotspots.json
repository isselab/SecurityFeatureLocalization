[
    {
        "projectName": "accumulo",
        "fileName": "PasswordTokenTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/client/security/tokens/PasswordTokenTest.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "43 - 43",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "accumulo",
        "fileName": "MiniAccumuloClusterClasspathTest.java",
        "filePath": "minicluster/src/test/java/org/apache/accumulo/minicluster/MiniAccumuloClusterClasspathTest.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "58 - 58",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "accumulo",
        "fileName": "MiniAccumuloClusterTest.java",
        "filePath": "minicluster/src/test/java/org/apache/accumulo/minicluster/MiniAccumuloClusterTest.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "66 - 66",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "accumulo",
        "fileName": "MiniAccumuloClusterTest.java",
        "filePath": "minicluster/src/test/java/org/apache/accumulo/minicluster/MiniAccumuloClusterTest.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "115 - 115",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "accumulo",
        "fileName": "SharedMiniClusterBase.java",
        "filePath": "test/src/main/java/org/apache/accumulo/harness/SharedMiniClusterBase.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "110 - 110",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "accumulo",
        "fileName": "AccumuloMiniClusterConfiguration.java",
        "filePath": "test/src/main/java/org/apache/accumulo/harness/conf/AccumuloMiniClusterConfiguration.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "97 - 97",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "accumulo",
        "fileName": "StandaloneAccumuloClusterConfiguration.java",
        "filePath": "test/src/main/java/org/apache/accumulo/harness/conf/StandaloneAccumuloClusterConfiguration.java",
        "Security Category": "auth",
        "Description": "Hard-coded passwords are security-sensitive",
        "Location": "158 - 158",
        "Severity": "HIGH",
        "Best Practices": "Recommended Secure Coding Practices\nStore the credentials in a configuration file that is not pushed to the code repository.\nStore the credentials in a database.\nUse your cloud provider\u2019s service for managing secrets.\nIf a password has been disclosed through the source code: change it.\nCompliant Solution\nString username = getEncryptedUser();\nString password = getEncryptedPassword();\nConnection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\n\"user=\" + username + \"&password=\" + password);\nSee\nOWASP -\nTop 10 2021 Category A7 - Identification and\nAuthentication Failures\nOWASP -\nTop 10 2017 Category A2 - Broken Authentication\nCWE -\nCWE-798 - Use of Hard-coded Credentials\nCWE -\nCWE-259 - Use of Hard-coded Password\nCERT, MSC03-J.\n- Never hard code sensitive information\nDerived from FindSecBugs rule\nHard Coded Password"
    },
    {
        "projectName": "accumulo",
        "fileName": "PropertyType.java",
        "filePath": "core/src/main/java/org/apache/accumulo/core/conf/PropertyType.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "245 - 245",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "VolumeImpl.java",
        "filePath": "core/src/main/java/org/apache/accumulo/core/volume/VolumeImpl.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "58 - 58",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "VerifySerialRecoveryIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/VerifySerialRecoveryIT.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "127 - 127",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "FateOpsCommandsIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/fate/FateOpsCommandsIT.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "122 - 122",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "FateOpsCommandsIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/fate/FateOpsCommandsIT.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "144 - 144",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "FateOpsCommandsIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/fate/FateOpsCommandsIT.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "166 - 166",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "FateOpsCommandsIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/fate/FateOpsCommandsIT.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "184 - 184",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "FateOpsCommandsIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/fate/FateOpsCommandsIT.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "203 - 203",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "FateOpsCommandsIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/fate/FateOpsCommandsIT.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "225 - 225",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "FateOpsCommandsIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/fate/FateOpsCommandsIT.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "242 - 242",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "FateOpsCommandsIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/fate/FateOpsCommandsIT.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "263 - 263",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "FateOpsCommandsIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/fate/FateOpsCommandsIT.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "284 - 284",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "FateOpsCommandsIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/fate/FateOpsCommandsIT.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "467 - 467",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "FateOpsCommandsIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/fate/FateOpsCommandsIT.java",
        "Security Category": "dos",
        "Description": "Using slow regular expressions is security-sensitive",
        "Location": "752 - 752",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nTo avoid\ncatastrophic backtracking\nsituations, make sure that none of the following conditions apply to your regular expression.\nIn all of the following cases, catastrophic backtracking can only happen if the problematic part of the regex is followed by a pattern that can\nfail, causing the backtracking to actually happen. Note that when performing a full match (e.g. using\nString.matches\n), the end of the\nregex counts as a pattern that can fail because it will only succeed when the end of the string is reached.\nIf you have a non-possessive repetition\nr*\nor\nr*?\n, such that the regex\nr\ncould produce different\npossible matches (of possibly different lengths) on the same input, the worst case matching time can be exponential. This can be the case if\nr\ncontains optional parts, alternations or additional repetitions (but not if the repetition is written in such a way that there\u2019s only\none way to match it).\nWhen using JDK 9 or later an optimization applies when the repetition is greedy and the entire regex does not contain any back references.\nIn that case the runtime will only be polynomial (in case of nested repetitions) or even linear (in case of alternations or optional parts).\nIf you have multiple non-possessive repetitions that can match the same contents and are consecutive or are only separated by an optional\nseparator or a separator that can be matched by both of the repetitions, the worst case matching time can be polynomial (O(n^c) where c is the\nnumber of problematic repetitions). For example\na*b*\nis not a problem because\na*\nand\nb*\nmatch different\nthings and\na*_a*\nis not a problem because the repetitions are separated by a\n'_'\nand can\u2019t match that\n'_'\n.\nHowever,\na*a*\nand\n.*_.*\nhave quadratic runtime.\nIf you\u2019re performing a partial match (such as by using\nMatcher.find\n,\nString.split\n,\nString.replaceAll\netc.) and the regex is not anchored to the beginning of the string, quadratic runtime is especially hard to avoid because whenever a match fails,\nthe regex engine will try again starting at the next index. This means that any unbounded repetition (even a possessive one), if it\u2019s followed by a\npattern that can fail, can cause quadratic runtime on some inputs. For example\nstr.split(\"\\\\s*,\")\nwill run in quadratic time on strings\nthat consist entirely of spaces (or at least contain large sequences of spaces, not followed by a comma).\nIn order to rewrite your regular expression without these patterns, consider the following strategies:\nIf applicable, define a maximum number of expected repetitions using the bounded quantifiers, like\n{1,5}\ninstead of\n+\nfor instance.\nRefactor\nnested quantifiers\nto limit the number of way the inner group can be matched by the outer quantifier, for instance this\nnested quantifier situation\n(ba+)+\ndoesn\u2019t cause performance issues, indeed, the inner group can be matched only if there exists\nexactly one\nb\nchar per repetition of the group.\nOptimize regular expressions with\npossessive quantifiers\nand\natomic grouping\n.\nUse negated character classes instead of\n.\nto exclude separators where applicable. For example the quadratic regex\n.*_.*\ncan be made linear by changing it to\n[^_]*_.*\nSometimes it\u2019s not possible to rewrite the regex to be linear while still matching what you want it to match. Especially when using partial\nmatches, for which it is quite hard to avoid quadratic runtimes. In those cases consider the following approaches:\nSolve the problem without regular expressions\nUse an alternative non-backtracking regex implementations such as Google\u2019s\nRE2\nor\nRE2/J\n.\nUse multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or\nusing multiple regular expressions. One example of this would be to replace\nstr.split(\"\\\\s*,\\\\s*\")\nwith\nstr.split(\",\")\nand\nthen trimming the spaces from the strings as a second step.\nWhen using\nMatcher.find()\n, it is often possible to make the regex infallible by making all the parts that could fail optional,\nwhich will prevent backtracking. Of course this means that you\u2019ll accept more strings than intended, but this can be handled by using capturing\ngroups to check whether the optional parts were matched or not and then ignoring the match if they weren\u2019t. For example the regex\nx*y\ncould be replaced with\nx*(y)?\nand then the call to\nmatcher.find()\ncould be replaced with\nmatcher.find() &&\nmatcher.group(1) != null\n.\nCompliant Solution\nPossessive quantifiers do not keep backtracking positions, thus can be used, if possible, to avoid performance issues:\njava.util.regex.Pattern.compile(\"(a+)++\").matcher(\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"+\n\"aaaaaaaaaaaaaaa!\").matches(); // Compliant\njava.util.regex.Pattern.compile(\"(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*+\").matcher(\n\"hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchi\"+\n\"cchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihi\"+\n\"chicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccch\"+\n\"chhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihh\"+\n\"ichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihih\"+\n\"iihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci\").matches(); // Compliant\nSee\nOWASP -\nTop 10 2017 Category A1 - Injection\nCWE -\nCWE-400 - Uncontrolled Resource Consumption\nCWE -\nCWE-1333 - Inefficient Regular Expression Complexity\nowasp.org\n- OWASP Regular expression Denial\nof Service - ReDoS\nstackstatus.net(archived)\n- Outage Postmortem - July 20, 2016\nregular-expressions.info\n- Runaway Regular Expressions: Catastrophic\nBacktracking\ndocs.microsoft.com\n- Backtracking with Nested Optional Quantifiers"
    },
    {
        "projectName": "accumulo",
        "fileName": "ServerConfigurationFactory.java",
        "filePath": "server/base/src/main/java/org/apache/accumulo/server/conf/ServerConfigurationFactory.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "268 - 268",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "PropCacheCaffeineImplTest.java",
        "filePath": "server/base/src/test/java/org/apache/accumulo/server/conf/store/impl/PropCacheCaffeineImplTest.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "70 - 70",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "PropCacheCaffeineImplTest.java",
        "filePath": "server/base/src/test/java/org/apache/accumulo/server/conf/store/impl/PropCacheCaffeineImplTest.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "109 - 109",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "PropCacheCaffeineImplTest.java",
        "filePath": "server/base/src/test/java/org/apache/accumulo/server/conf/store/impl/PropCacheCaffeineImplTest.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "135 - 135",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "ScanConsistencyIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/ScanConsistencyIT.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "128 - 128",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "ScanConsistencyIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/ScanConsistencyIT.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "428 - 428",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "ScanConsistencyIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/ScanConsistencyIT.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "525 - 525",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "ScanConsistencyIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/ScanConsistencyIT.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "639 - 639",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "TestIngest.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/TestIngest.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "242 - 242",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "LargeRowIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/functional/LargeRowIT.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "95 - 95",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "LargeRowIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/functional/LargeRowIT.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "139 - 139",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "LargeRowIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/functional/LargeRowIT.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "175 - 175",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "SplitMillionIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/functional/SplitMillionIT.java",
        "Security Category": "weak-cryptography",
        "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive",
        "Location": "108 - 108",
        "Severity": "MEDIUM",
        "Best Practices": "Recommended Secure Coding Practices\nUse a cryptographically strong random number generator (RNG) like \"java.security.SecureRandom\" in place of this PRNG.\nUse the generated random values only once.\nYou should not expose the generated random value. If you have to store it, make sure that the database or file is secure.\nCompliant Solution\nSecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases\nbyte bytes[] = new byte[20];\nrandom.nextBytes(bytes);\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nCWE -\nCWE-330 - Use of Insufficiently Random Values\nCWE -\nCWE-326 - Inadequate Encryption Strength\nCWE -\nCWE-1241 - Use of Predictable Algorithm in Random Number Generator\nCERT, MSC02-J.\n- Generate strong random numbers\nCERT, MSC30-C.\n- Do not use the rand() function for generating pseudorandom numbers\nCERT, MSC50-CPP.\n- Do not use std::rand() for generating pseudorandom numbers\nDerived from FindSecBugs rule\nPredictable Pseudo Random Number\nGenerator"
    },
    {
        "projectName": "accumulo",
        "fileName": "AccumuloUncaughtExceptionHandler.java",
        "filePath": "core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java",
        "Security Category": "insecure-conf",
        "Description": "Delivering code in production with debug features activated is security-sensitive",
        "Location": "69 - 69",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDo not enable debugging features on production servers or applications distributed to end users.\nCompliant Solution\nLoggers should be used (instead of\nprintStackTrace\n) to print throwables:\ntry {\n/* ... */\n} catch(Exception e) {\nLOGGER.log(\"context\", e);\n}\nEnableWebSecurity\nannotation for SpringFramework with\ndebug\nto\nfalse\ndisables debugging support:\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n@Configuration\n@EnableWebSecurity(debug = false)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n// ...\n}\nWebView.setWebContentsDebuggingEnabled(false)\nfor Android disables debugging support:\nimport android.webkit.WebView;\nWebView.setWebContentsDebuggingEnabled(false);\nWebView.getFactory().getStatics().setWebContentsDebuggingEnabled(false);\nSee\nOWASP -\nTop 10 2021 Category A5 - Security Misconfiguration\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCWE -\nCWE-489 - Active Debug Code\nCWE -\nCWE-215 - Information Exposure Through Debug Information"
    },
    {
        "projectName": "accumulo",
        "fileName": "MultiThreadedRFileTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/file/rfile/MultiThreadedRFileTest.java",
        "Security Category": "insecure-conf",
        "Description": "Delivering code in production with debug features activated is security-sensitive",
        "Location": "260 - 260",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDo not enable debugging features on production servers or applications distributed to end users.\nCompliant Solution\nLoggers should be used (instead of\nprintStackTrace\n) to print throwables:\ntry {\n/* ... */\n} catch(Exception e) {\nLOGGER.log(\"context\", e);\n}\nEnableWebSecurity\nannotation for SpringFramework with\ndebug\nto\nfalse\ndisables debugging support:\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n@Configuration\n@EnableWebSecurity(debug = false)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n// ...\n}\nWebView.setWebContentsDebuggingEnabled(false)\nfor Android disables debugging support:\nimport android.webkit.WebView;\nWebView.setWebContentsDebuggingEnabled(false);\nWebView.getFactory().getStatics().setWebContentsDebuggingEnabled(false);\nSee\nOWASP -\nTop 10 2021 Category A5 - Security Misconfiguration\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCWE -\nCWE-489 - Active Debug Code\nCWE -\nCWE-215 - Information Exposure Through Debug Information"
    },
    {
        "projectName": "accumulo",
        "fileName": "AccumuloOutputFormatIT.java",
        "filePath": "hadoop-mapreduce/src/test/java/org/apache/accumulo/hadoop/its/mapred/AccumuloOutputFormatIT.java",
        "Security Category": "insecure-conf",
        "Description": "Delivering code in production with debug features activated is security-sensitive",
        "Location": "103 - 103",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDo not enable debugging features on production servers or applications distributed to end users.\nCompliant Solution\nLoggers should be used (instead of\nprintStackTrace\n) to print throwables:\ntry {\n/* ... */\n} catch(Exception e) {\nLOGGER.log(\"context\", e);\n}\nEnableWebSecurity\nannotation for SpringFramework with\ndebug\nto\nfalse\ndisables debugging support:\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n@Configuration\n@EnableWebSecurity(debug = false)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n// ...\n}\nWebView.setWebContentsDebuggingEnabled(false)\nfor Android disables debugging support:\nimport android.webkit.WebView;\nWebView.setWebContentsDebuggingEnabled(false);\nWebView.getFactory().getStatics().setWebContentsDebuggingEnabled(false);\nSee\nOWASP -\nTop 10 2021 Category A5 - Security Misconfiguration\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCWE -\nCWE-489 - Active Debug Code\nCWE -\nCWE-215 - Information Exposure Through Debug Information"
    },
    {
        "projectName": "accumulo",
        "fileName": "CheckTabletMetadataTest.java",
        "filePath": "server/tserver/src/test/java/org/apache/accumulo/tserver/CheckTabletMetadataTest.java",
        "Security Category": "insecure-conf",
        "Description": "Delivering code in production with debug features activated is security-sensitive",
        "Location": "72 - 72",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDo not enable debugging features on production servers or applications distributed to end users.\nCompliant Solution\nLoggers should be used (instead of\nprintStackTrace\n) to print throwables:\ntry {\n/* ... */\n} catch(Exception e) {\nLOGGER.log(\"context\", e);\n}\nEnableWebSecurity\nannotation for SpringFramework with\ndebug\nto\nfalse\ndisables debugging support:\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n@Configuration\n@EnableWebSecurity(debug = false)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n// ...\n}\nWebView.setWebContentsDebuggingEnabled(false)\nfor Android disables debugging support:\nimport android.webkit.WebView;\nWebView.setWebContentsDebuggingEnabled(false);\nWebView.getFactory().getStatics().setWebContentsDebuggingEnabled(false);\nSee\nOWASP -\nTop 10 2021 Category A5 - Security Misconfiguration\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCWE -\nCWE-489 - Active Debug Code\nCWE -\nCWE-215 - Information Exposure Through Debug Information"
    },
    {
        "projectName": "accumulo",
        "fileName": "CheckTabletMetadataTest.java",
        "filePath": "server/tserver/src/test/java/org/apache/accumulo/tserver/CheckTabletMetadataTest.java",
        "Security Category": "insecure-conf",
        "Description": "Delivering code in production with debug features activated is security-sensitive",
        "Location": "85 - 85",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDo not enable debugging features on production servers or applications distributed to end users.\nCompliant Solution\nLoggers should be used (instead of\nprintStackTrace\n) to print throwables:\ntry {\n/* ... */\n} catch(Exception e) {\nLOGGER.log(\"context\", e);\n}\nEnableWebSecurity\nannotation for SpringFramework with\ndebug\nto\nfalse\ndisables debugging support:\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n@Configuration\n@EnableWebSecurity(debug = false)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n// ...\n}\nWebView.setWebContentsDebuggingEnabled(false)\nfor Android disables debugging support:\nimport android.webkit.WebView;\nWebView.setWebContentsDebuggingEnabled(false);\nWebView.getFactory().getStatics().setWebContentsDebuggingEnabled(false);\nSee\nOWASP -\nTop 10 2021 Category A5 - Security Misconfiguration\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCWE -\nCWE-489 - Active Debug Code\nCWE -\nCWE-215 - Information Exposure Through Debug Information"
    },
    {
        "projectName": "accumulo",
        "fileName": "Main.java",
        "filePath": "start/src/main/java/org/apache/accumulo/start/Main.java",
        "Security Category": "insecure-conf",
        "Description": "Delivering code in production with debug features activated is security-sensitive",
        "Location": "155 - 155",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDo not enable debugging features on production servers or applications distributed to end users.\nCompliant Solution\nLoggers should be used (instead of\nprintStackTrace\n) to print throwables:\ntry {\n/* ... */\n} catch(Exception e) {\nLOGGER.log(\"context\", e);\n}\nEnableWebSecurity\nannotation for SpringFramework with\ndebug\nto\nfalse\ndisables debugging support:\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n@Configuration\n@EnableWebSecurity(debug = false)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n// ...\n}\nWebView.setWebContentsDebuggingEnabled(false)\nfor Android disables debugging support:\nimport android.webkit.WebView;\nWebView.setWebContentsDebuggingEnabled(false);\nWebView.getFactory().getStatics().setWebContentsDebuggingEnabled(false);\nSee\nOWASP -\nTop 10 2021 Category A5 - Security Misconfiguration\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCWE -\nCWE-489 - Active Debug Code\nCWE -\nCWE-215 - Information Exposure Through Debug Information"
    },
    {
        "projectName": "accumulo",
        "fileName": "InterruptibleScannersIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/InterruptibleScannersIT.java",
        "Security Category": "insecure-conf",
        "Description": "Delivering code in production with debug features activated is security-sensitive",
        "Location": "88 - 88",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDo not enable debugging features on production servers or applications distributed to end users.\nCompliant Solution\nLoggers should be used (instead of\nprintStackTrace\n) to print throwables:\ntry {\n/* ... */\n} catch(Exception e) {\nLOGGER.log(\"context\", e);\n}\nEnableWebSecurity\nannotation for SpringFramework with\ndebug\nto\nfalse\ndisables debugging support:\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n@Configuration\n@EnableWebSecurity(debug = false)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n// ...\n}\nWebView.setWebContentsDebuggingEnabled(false)\nfor Android disables debugging support:\nimport android.webkit.WebView;\nWebView.setWebContentsDebuggingEnabled(false);\nWebView.getFactory().getStatics().setWebContentsDebuggingEnabled(false);\nSee\nOWASP -\nTop 10 2021 Category A5 - Security Misconfiguration\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCWE -\nCWE-489 - Active Debug Code\nCWE -\nCWE-215 - Information Exposure Through Debug Information"
    },
    {
        "projectName": "accumulo",
        "fileName": "ManagerAssignmentIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/functional/ManagerAssignmentIT.java",
        "Security Category": "insecure-conf",
        "Description": "Delivering code in production with debug features activated is security-sensitive",
        "Location": "514 - 514",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDo not enable debugging features on production servers or applications distributed to end users.\nCompliant Solution\nLoggers should be used (instead of\nprintStackTrace\n) to print throwables:\ntry {\n/* ... */\n} catch(Exception e) {\nLOGGER.log(\"context\", e);\n}\nEnableWebSecurity\nannotation for SpringFramework with\ndebug\nto\nfalse\ndisables debugging support:\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n@Configuration\n@EnableWebSecurity(debug = false)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n// ...\n}\nWebView.setWebContentsDebuggingEnabled(false)\nfor Android disables debugging support:\nimport android.webkit.WebView;\nWebView.setWebContentsDebuggingEnabled(false);\nWebView.getFactory().getStatics().setWebContentsDebuggingEnabled(false);\nSee\nOWASP -\nTop 10 2021 Category A5 - Security Misconfiguration\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCWE -\nCWE-489 - Active Debug Code\nCWE -\nCWE-215 - Information Exposure Through Debug Information"
    },
    {
        "projectName": "accumulo",
        "fileName": "MapReduceIT.java",
        "filePath": "hadoop-mapreduce/src/test/java/org/apache/accumulo/hadoop/its/mapreduce/MapReduceIT.java",
        "Security Category": "others",
        "Description": "Using weak hashing algorithms is security-sensitive",
        "Location": "98 - 98",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nSafer alternatives, such as\nSHA-256\n,\nSHA-512\n,\nSHA-3\nare recommended, and for password hashing, it\u2019s even\nbetter to use algorithms that do not compute too \"quickly\", like\nbcrypt\n,\nscrypt\n,\nargon2\nor\npbkdf2\nbecause it slows down\nbrute force attacks\n.\nCompliant Solution\nMessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // Compliant\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-1240 - Use of a Risky Cryptographic Primitive"
    },
    {
        "projectName": "accumulo",
        "fileName": "RowHashIT.java",
        "filePath": "hadoop-mapreduce/src/test/java/org/apache/accumulo/hadoop/its/mapreduce/RowHashIT.java",
        "Security Category": "others",
        "Description": "Using weak hashing algorithms is security-sensitive",
        "Location": "115 - 115",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nSafer alternatives, such as\nSHA-256\n,\nSHA-512\n,\nSHA-3\nare recommended, and for password hashing, it\u2019s even\nbetter to use algorithms that do not compute too \"quickly\", like\nbcrypt\n,\nscrypt\n,\nargon2\nor\npbkdf2\nbecause it slows down\nbrute force attacks\n.\nCompliant Solution\nMessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // Compliant\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-1240 - Use of a Risky Cryptographic Primitive"
    },
    {
        "projectName": "accumulo",
        "fileName": "SaslDigestCallbackHandlerTest.java",
        "filePath": "server/base/src/test/java/org/apache/accumulo/server/rpc/SaslDigestCallbackHandlerTest.java",
        "Security Category": "others",
        "Description": "Using weak hashing algorithms is security-sensitive",
        "Location": "62 - 62",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nSafer alternatives, such as\nSHA-256\n,\nSHA-512\n,\nSHA-3\nare recommended, and for password hashing, it\u2019s even\nbetter to use algorithms that do not compute too \"quickly\", like\nbcrypt\n,\nscrypt\n,\nargon2\nor\npbkdf2\nbecause it slows down\nbrute force attacks\n.\nCompliant Solution\nMessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // Compliant\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-1240 - Use of a Risky Cryptographic Primitive"
    },
    {
        "projectName": "accumulo",
        "fileName": "AuthenticationKeyTest.java",
        "filePath": "server/base/src/test/java/org/apache/accumulo/server/security/delegation/AuthenticationKeyTest.java",
        "Security Category": "others",
        "Description": "Using weak hashing algorithms is security-sensitive",
        "Location": "46 - 46",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nSafer alternatives, such as\nSHA-256\n,\nSHA-512\n,\nSHA-3\nare recommended, and for password hashing, it\u2019s even\nbetter to use algorithms that do not compute too \"quickly\", like\nbcrypt\n,\nscrypt\n,\nargon2\nor\npbkdf2\nbecause it slows down\nbrute force attacks\n.\nCompliant Solution\nMessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // Compliant\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-1240 - Use of a Risky Cryptographic Primitive"
    },
    {
        "projectName": "accumulo",
        "fileName": "AuthenticationTokenKeyManagerTest.java",
        "filePath": "server/base/src/test/java/org/apache/accumulo/server/security/delegation/AuthenticationTokenKeyManagerTest.java",
        "Security Category": "others",
        "Description": "Using weak hashing algorithms is security-sensitive",
        "Location": "54 - 54",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nSafer alternatives, such as\nSHA-256\n,\nSHA-512\n,\nSHA-3\nare recommended, and for password hashing, it\u2019s even\nbetter to use algorithms that do not compute too \"quickly\", like\nbcrypt\n,\nscrypt\n,\nargon2\nor\npbkdf2\nbecause it slows down\nbrute force attacks\n.\nCompliant Solution\nMessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // Compliant\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-1240 - Use of a Risky Cryptographic Primitive"
    },
    {
        "projectName": "accumulo",
        "fileName": "AuthenticationTokenSecretManagerTest.java",
        "filePath": "server/base/src/test/java/org/apache/accumulo/server/security/delegation/AuthenticationTokenSecretManagerTest.java",
        "Security Category": "others",
        "Description": "Using weak hashing algorithms is security-sensitive",
        "Location": "76 - 76",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nSafer alternatives, such as\nSHA-256\n,\nSHA-512\n,\nSHA-3\nare recommended, and for password hashing, it\u2019s even\nbetter to use algorithms that do not compute too \"quickly\", like\nbcrypt\n,\nscrypt\n,\nargon2\nor\npbkdf2\nbecause it slows down\nbrute force attacks\n.\nCompliant Solution\nMessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // Compliant\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-1240 - Use of a Risky Cryptographic Primitive"
    },
    {
        "projectName": "accumulo",
        "fileName": "ZooAuthenticationKeyDistributorTest.java",
        "filePath": "server/base/src/test/java/org/apache/accumulo/server/security/delegation/ZooAuthenticationKeyDistributorTest.java",
        "Security Category": "others",
        "Description": "Using weak hashing algorithms is security-sensitive",
        "Location": "61 - 61",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nSafer alternatives, such as\nSHA-256\n,\nSHA-512\n,\nSHA-3\nare recommended, and for password hashing, it\u2019s even\nbetter to use algorithms that do not compute too \"quickly\", like\nbcrypt\n,\nscrypt\n,\nargon2\nor\npbkdf2\nbecause it slows down\nbrute force attacks\n.\nCompliant Solution\nMessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // Compliant\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-1240 - Use of a Risky Cryptographic Primitive"
    },
    {
        "projectName": "accumulo",
        "fileName": "ZooAuthenticationKeyWatcherTest.java",
        "filePath": "server/base/src/test/java/org/apache/accumulo/server/security/delegation/ZooAuthenticationKeyWatcherTest.java",
        "Security Category": "others",
        "Description": "Using weak hashing algorithms is security-sensitive",
        "Location": "63 - 63",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nSafer alternatives, such as\nSHA-256\n,\nSHA-512\n,\nSHA-3\nare recommended, and for password hashing, it\u2019s even\nbetter to use algorithms that do not compute too \"quickly\", like\nbcrypt\n,\nscrypt\n,\nargon2\nor\npbkdf2\nbecause it slows down\nbrute force attacks\n.\nCompliant Solution\nMessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // Compliant\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-1240 - Use of a Risky Cryptographic Primitive"
    },
    {
        "projectName": "accumulo",
        "fileName": "CompactionPriorityQueueMetricsIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/compaction/CompactionPriorityQueueMetricsIT.java",
        "Security Category": "others",
        "Description": "Using weak hashing algorithms is security-sensitive",
        "Location": "290 - 290",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nSafer alternatives, such as\nSHA-256\n,\nSHA-512\n,\nSHA-3\nare recommended, and for password hashing, it\u2019s even\nbetter to use algorithms that do not compute too \"quickly\", like\nbcrypt\n,\nscrypt\n,\nargon2\nor\npbkdf2\nbecause it slows down\nbrute force attacks\n.\nCompliant Solution\nMessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // Compliant\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-1240 - Use of a Risky Cryptographic Primitive"
    },
    {
        "projectName": "accumulo",
        "fileName": "BulkNewIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/functional/BulkNewIT.java",
        "Security Category": "others",
        "Description": "Using weak hashing algorithms is security-sensitive",
        "Location": "937 - 937",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nSafer alternatives, such as\nSHA-256\n,\nSHA-512\n,\nSHA-3\nare recommended, and for password hashing, it\u2019s even\nbetter to use algorithms that do not compute too \"quickly\", like\nbcrypt\n,\nscrypt\n,\nargon2\nor\npbkdf2\nbecause it slows down\nbrute force attacks\n.\nCompliant Solution\nMessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // Compliant\nSee\nOWASP -\nTop 10 2021 Category A2 - Cryptographic Failures\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nOWASP -\nMobile AppSec\nVerification Standard - Cryptography Requirements\nOWASP -\nMobile Top 10 2016 Category M5 -\nInsufficient Cryptography\nCWE -\nCWE-1240 - Use of a Risky Cryptographic Primitive"
    },
    {
        "projectName": "accumulo",
        "fileName": "TableOperationsImpl.java",
        "filePath": "core/src/main/java/org/apache/accumulo/core/clientImpl/TableOperationsImpl.java",
        "Security Category": "others",
        "Description": "Expanding archive files without controlling resource consumption is security-sensitive",
        "Location": "1636 - 1636",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDefine and control the ratio between compressed and uncompressed data, in general the data compression ratio for most of the legit archives is\n1 to 3.\nDefine and control the threshold for maximum total size of the uncompressed data.\nCount the number of file entries extracted from the archive and abort the extraction if their number is greater than a predefined threshold, in\nparticular it\u2019s not recommended to recursively expand archives (an entry of an archive could be also an archive).\nCompliant Solution\nDo not rely on\ngetsize\nto retrieve the size of an\nuncompressed entry because this method returns what is defined in the archive headers which can be forged by attackers, instead calculate the actual\nentry size when unzipping it:\nFile f = new File(\"ZipBomb.zip\");\nZipFile zipFile = new ZipFile(f);\nEnumeration<? extends ZipEntry> entries = zipFile.entries();\nint THRESHOLD_ENTRIES = 10000;\nint THRESHOLD_SIZE = 1000000000; // 1 GB\ndouble THRESHOLD_RATIO = 10;\nint totalSizeArchive = 0;\nint totalEntryArchive = 0;\nwhile(entries.hasMoreElements()) {\nZipEntry ze = entries.nextElement();\nInputStream in = new BufferedInputStream(zipFile.getInputStream(ze));\nOutputStream out = new BufferedOutputStream(new FileOutputStream(\"./output_onlyfortesting.txt\"));\ntotalEntryArchive ++;\nint nBytes = -1;\nbyte[] buffer = new byte[2048];\nint totalSizeEntry = 0;\nwhile((nBytes = in.read(buffer)) > 0) { // Compliant\nout.write(buffer, 0, nBytes);\ntotalSizeEntry += nBytes;\ntotalSizeArchive += nBytes;\ndouble compressionRatio = totalSizeEntry / ze.getCompressedSize();\nif(compressionRatio > THRESHOLD_RATIO) {\n// ratio between compressed and uncompressed data is highly suspicious, looks like a Zip Bomb Attack\nbreak;\n}\n}\nif(totalSizeArchive > THRESHOLD_SIZE) {\n// the uncompressed data size is too much for the application resource capacity\nbreak;\n}\nif(totalEntryArchive > THRESHOLD_ENTRIES) {\n// too much entries in this archive, can lead to inodes exhaustion of the system\nbreak;\n}\n}\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2021 Category A5 - Security Misconfiguration\nOWASP -\nTop 10 2017 Category A5 - Broken Access Control\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nCWE -\nCWE-409 - Improper Handling of Highly Compressed Data (Data Amplification)\nCERT, IDS04-J.\n- Safely\nextract files from ZipInputStream\nbamsoftware.com\n- A better Zip Bomb"
    },
    {
        "projectName": "accumulo",
        "fileName": "ImportTable.java",
        "filePath": "server/manager/src/main/java/org/apache/accumulo/manager/tableOps/tableImport/ImportTable.java",
        "Security Category": "others",
        "Description": "Expanding archive files without controlling resource consumption is security-sensitive",
        "Location": "125 - 125",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDefine and control the ratio between compressed and uncompressed data, in general the data compression ratio for most of the legit archives is\n1 to 3.\nDefine and control the threshold for maximum total size of the uncompressed data.\nCount the number of file entries extracted from the archive and abort the extraction if their number is greater than a predefined threshold, in\nparticular it\u2019s not recommended to recursively expand archives (an entry of an archive could be also an archive).\nCompliant Solution\nDo not rely on\ngetsize\nto retrieve the size of an\nuncompressed entry because this method returns what is defined in the archive headers which can be forged by attackers, instead calculate the actual\nentry size when unzipping it:\nFile f = new File(\"ZipBomb.zip\");\nZipFile zipFile = new ZipFile(f);\nEnumeration<? extends ZipEntry> entries = zipFile.entries();\nint THRESHOLD_ENTRIES = 10000;\nint THRESHOLD_SIZE = 1000000000; // 1 GB\ndouble THRESHOLD_RATIO = 10;\nint totalSizeArchive = 0;\nint totalEntryArchive = 0;\nwhile(entries.hasMoreElements()) {\nZipEntry ze = entries.nextElement();\nInputStream in = new BufferedInputStream(zipFile.getInputStream(ze));\nOutputStream out = new BufferedOutputStream(new FileOutputStream(\"./output_onlyfortesting.txt\"));\ntotalEntryArchive ++;\nint nBytes = -1;\nbyte[] buffer = new byte[2048];\nint totalSizeEntry = 0;\nwhile((nBytes = in.read(buffer)) > 0) { // Compliant\nout.write(buffer, 0, nBytes);\ntotalSizeEntry += nBytes;\ntotalSizeArchive += nBytes;\ndouble compressionRatio = totalSizeEntry / ze.getCompressedSize();\nif(compressionRatio > THRESHOLD_RATIO) {\n// ratio between compressed and uncompressed data is highly suspicious, looks like a Zip Bomb Attack\nbreak;\n}\n}\nif(totalSizeArchive > THRESHOLD_SIZE) {\n// the uncompressed data size is too much for the application resource capacity\nbreak;\n}\nif(totalEntryArchive > THRESHOLD_ENTRIES) {\n// too much entries in this archive, can lead to inodes exhaustion of the system\nbreak;\n}\n}\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2021 Category A5 - Security Misconfiguration\nOWASP -\nTop 10 2017 Category A5 - Broken Access Control\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nCWE -\nCWE-409 - Improper Handling of Highly Compressed Data (Data Amplification)\nCERT, IDS04-J.\n- Safely\nextract files from ZipInputStream\nbamsoftware.com\n- A better Zip Bomb"
    },
    {
        "projectName": "accumulo",
        "fileName": "PopulateMetadataTable.java",
        "filePath": "server/manager/src/main/java/org/apache/accumulo/manager/tableOps/tableImport/PopulateMetadataTable.java",
        "Security Category": "others",
        "Description": "Expanding archive files without controlling resource consumption is security-sensitive",
        "Location": "119 - 119",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDefine and control the ratio between compressed and uncompressed data, in general the data compression ratio for most of the legit archives is\n1 to 3.\nDefine and control the threshold for maximum total size of the uncompressed data.\nCount the number of file entries extracted from the archive and abort the extraction if their number is greater than a predefined threshold, in\nparticular it\u2019s not recommended to recursively expand archives (an entry of an archive could be also an archive).\nCompliant Solution\nDo not rely on\ngetsize\nto retrieve the size of an\nuncompressed entry because this method returns what is defined in the archive headers which can be forged by attackers, instead calculate the actual\nentry size when unzipping it:\nFile f = new File(\"ZipBomb.zip\");\nZipFile zipFile = new ZipFile(f);\nEnumeration<? extends ZipEntry> entries = zipFile.entries();\nint THRESHOLD_ENTRIES = 10000;\nint THRESHOLD_SIZE = 1000000000; // 1 GB\ndouble THRESHOLD_RATIO = 10;\nint totalSizeArchive = 0;\nint totalEntryArchive = 0;\nwhile(entries.hasMoreElements()) {\nZipEntry ze = entries.nextElement();\nInputStream in = new BufferedInputStream(zipFile.getInputStream(ze));\nOutputStream out = new BufferedOutputStream(new FileOutputStream(\"./output_onlyfortesting.txt\"));\ntotalEntryArchive ++;\nint nBytes = -1;\nbyte[] buffer = new byte[2048];\nint totalSizeEntry = 0;\nwhile((nBytes = in.read(buffer)) > 0) { // Compliant\nout.write(buffer, 0, nBytes);\ntotalSizeEntry += nBytes;\ntotalSizeArchive += nBytes;\ndouble compressionRatio = totalSizeEntry / ze.getCompressedSize();\nif(compressionRatio > THRESHOLD_RATIO) {\n// ratio between compressed and uncompressed data is highly suspicious, looks like a Zip Bomb Attack\nbreak;\n}\n}\nif(totalSizeArchive > THRESHOLD_SIZE) {\n// the uncompressed data size is too much for the application resource capacity\nbreak;\n}\nif(totalEntryArchive > THRESHOLD_ENTRIES) {\n// too much entries in this archive, can lead to inodes exhaustion of the system\nbreak;\n}\n}\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2021 Category A5 - Security Misconfiguration\nOWASP -\nTop 10 2017 Category A5 - Broken Access Control\nOWASP -\nTop 10 2017 Category A6 - Security\nMisconfiguration\nCWE -\nCWE-409 - Improper Handling of Highly Compressed Data (Data Amplification)\nCERT, IDS04-J.\n- Safely\nextract files from ZipInputStream\nbamsoftware.com\n- A better Zip Bomb"
    },
    {
        "projectName": "accumulo",
        "fileName": "MultiThreadedRFileTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/file/rfile/MultiThreadedRFileTest.java",
        "Security Category": "others",
        "Description": "Using publicly writable directories is security-sensitive",
        "Location": "152 - 152",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nUse a dedicated sub-folder with tightly controlled permissions\nUse secure-by-design APIs to create temporary files. Such API will make sure:\nThe generated filename is unpredictable\nThe file is readable and writable only by the creating user ID\nThe file descriptor is not inherited by child processes\nThe file will be destroyed as soon as it is closed\nCompliant Solution\nnew File(\"/myDirectory/myfile.txt\");  // Compliant\nFile.createTempFile(\"prefix\", \"suffix\", new File(\"/mySecureDirectory\"));  // Compliant\nif(SystemUtils.IS_OS_UNIX) {\nFileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwx------\"));\nFiles.createTempFile(\"prefix\", \"suffix\", attr); // Compliant\n}\nelse {\nFile f = Files.createTempFile(\"prefix\", \"suffix\").toFile();  // Compliant\nf.setReadable(true, true);\nf.setWritable(true, true);\nf.setExecutable(true, true);\n}\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A5 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCWE -\nCWE-377 - Insecure Temporary File\nCWE -\nCWE-379 - Creation of Temporary File in Directory with Incorrect Permissions\nOWASP, Insecure Temporary File\nSTIG Viewer -\nApplication Security and\nDevelopment: V-222567\n- The application must not be vulnerable to race conditions."
    },
    {
        "projectName": "accumulo",
        "fileName": "MiniAccumuloRunner.java",
        "filePath": "minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloRunner.java",
        "Security Category": "others",
        "Description": "Using publicly writable directories is security-sensitive",
        "Location": "172 - 172",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nUse a dedicated sub-folder with tightly controlled permissions\nUse secure-by-design APIs to create temporary files. Such API will make sure:\nThe generated filename is unpredictable\nThe file is readable and writable only by the creating user ID\nThe file descriptor is not inherited by child processes\nThe file will be destroyed as soon as it is closed\nCompliant Solution\nnew File(\"/myDirectory/myfile.txt\");  // Compliant\nFile.createTempFile(\"prefix\", \"suffix\", new File(\"/mySecureDirectory\"));  // Compliant\nif(SystemUtils.IS_OS_UNIX) {\nFileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwx------\"));\nFiles.createTempFile(\"prefix\", \"suffix\", attr); // Compliant\n}\nelse {\nFile f = Files.createTempFile(\"prefix\", \"suffix\").toFile();  // Compliant\nf.setReadable(true, true);\nf.setWritable(true, true);\nf.setExecutable(true, true);\n}\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A5 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCWE -\nCWE-377 - Insecure Temporary File\nCWE -\nCWE-379 - Creation of Temporary File in Directory with Incorrect Permissions\nOWASP, Insecure Temporary File\nSTIG Viewer -\nApplication Security and\nDevelopment: V-222567\n- The application must not be vulnerable to race conditions."
    },
    {
        "projectName": "accumulo",
        "fileName": "ShellConfigTest.java",
        "filePath": "shell/src/test/java/org/apache/accumulo/shell/ShellConfigTest.java",
        "Security Category": "others",
        "Description": "Using publicly writable directories is security-sensitive",
        "Location": "73 - 73",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nUse a dedicated sub-folder with tightly controlled permissions\nUse secure-by-design APIs to create temporary files. Such API will make sure:\nThe generated filename is unpredictable\nThe file is readable and writable only by the creating user ID\nThe file descriptor is not inherited by child processes\nThe file will be destroyed as soon as it is closed\nCompliant Solution\nnew File(\"/myDirectory/myfile.txt\");  // Compliant\nFile.createTempFile(\"prefix\", \"suffix\", new File(\"/mySecureDirectory\"));  // Compliant\nif(SystemUtils.IS_OS_UNIX) {\nFileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwx------\"));\nFiles.createTempFile(\"prefix\", \"suffix\", attr); // Compliant\n}\nelse {\nFile f = Files.createTempFile(\"prefix\", \"suffix\").toFile();  // Compliant\nf.setReadable(true, true);\nf.setWritable(true, true);\nf.setExecutable(true, true);\n}\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A5 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCWE -\nCWE-377 - Insecure Temporary File\nCWE -\nCWE-379 - Creation of Temporary File in Directory with Incorrect Permissions\nOWASP, Insecure Temporary File\nSTIG Viewer -\nApplication Security and\nDevelopment: V-222567\n- The application must not be vulnerable to race conditions."
    },
    {
        "projectName": "accumulo",
        "fileName": "ShellIT.java",
        "filePath": "test/src/main/java/org/apache/accumulo/test/shell/ShellIT.java",
        "Security Category": "others",
        "Description": "Using publicly writable directories is security-sensitive",
        "Location": "166 - 166",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nUse a dedicated sub-folder with tightly controlled permissions\nUse secure-by-design APIs to create temporary files. Such API will make sure:\nThe generated filename is unpredictable\nThe file is readable and writable only by the creating user ID\nThe file descriptor is not inherited by child processes\nThe file will be destroyed as soon as it is closed\nCompliant Solution\nnew File(\"/myDirectory/myfile.txt\");  // Compliant\nFile.createTempFile(\"prefix\", \"suffix\", new File(\"/mySecureDirectory\"));  // Compliant\nif(SystemUtils.IS_OS_UNIX) {\nFileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwx------\"));\nFiles.createTempFile(\"prefix\", \"suffix\", attr); // Compliant\n}\nelse {\nFile f = Files.createTempFile(\"prefix\", \"suffix\").toFile();  // Compliant\nf.setReadable(true, true);\nf.setWritable(true, true);\nf.setExecutable(true, true);\n}\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A5 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCWE -\nCWE-377 - Insecure Temporary File\nCWE -\nCWE-379 - Creation of Temporary File in Directory with Incorrect Permissions\nOWASP, Insecure Temporary File\nSTIG Viewer -\nApplication Security and\nDevelopment: V-222567\n- The application must not be vulnerable to race conditions."
    },
    {
        "projectName": "accumulo",
        "fileName": "ConfigOptsTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/cli/ConfigOptsTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "41 - 41",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "ReferencedTabletFileTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/metadata/schema/ReferencedTabletFileTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "103 - 103",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "114 - 114",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "115 - 115",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "116 - 116",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "117 - 117",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "118 - 118",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "119 - 119",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "120 - 120",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "121 - 121",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "122 - 122",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "123 - 123",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "124 - 124",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "125 - 125",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "126 - 126",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "127 - 127",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "128 - 128",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "130 - 130",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "132 - 132",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "134 - 134",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "136 - 136",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "138 - 138",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "140 - 140",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "142 - 142",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "144 - 144",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "146 - 146",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "148 - 148",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "150 - 150",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "152 - 152",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "154 - 154",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "156 - 156",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "158 - 158",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "162 - 162",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "164 - 164",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "166 - 166",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "208 - 208",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "208 - 208",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "208 - 208",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "209 - 209",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "209 - 209",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    },
    {
        "projectName": "accumulo",
        "fileName": "BaseHostRegexTableLoadBalancerTest.java",
        "filePath": "core/src/test/java/org/apache/accumulo/core/spi/balancer/BaseHostRegexTableLoadBalancerTest.java",
        "Security Category": "others",
        "Description": "Using hardcoded IP addresses is security-sensitive",
        "Location": "212 - 212",
        "Severity": "LOW",
        "Best Practices": "Recommended Secure Coding Practices\nDon\u2019t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nCompliant Solution\nString ip = System.getenv(\"IP_ADDRESS\"); // Compliant\nSocket socket = new Socket(ip, 6667);\nSee\nOWASP -\nTop 10 2021 Category A1 - Broken Access Control\nOWASP -\nTop 10 2017 Category A3 - Sensitive Data\nExposure\nCERT, MSC03-J.\n- Never hard code sensitive information"
    }
]